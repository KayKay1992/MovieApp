USEFETCH CUSTOM HOOK

Instaed of repeating the process of what we did in our previous lecture we can improve it by using what is known as custom hook, this hook will handle feetching the data in clean, reusable and scalable way. 

ðŸ” What is a Custom Hook in React?
A custom hook is a reusable JavaScript function that uses built-in React hooks (like useState, useEffect, useContext, etc.) to encapsulate logic that can be shared across multiple components.

âœ… Key Points:
Starts with use â€” It must begin with use (e.g., useFetch, useAuth, useForm) so React knows it's a hook.

Reusable Logic â€” It helps avoid repeating the same code (like fetching data, managing forms, auth, etc.) across components.

Not a Component â€” It doesn't return JSX; it returns values, functions, or state.

Works with Built-in Hooks â€” You can use other hooks like useState, useEffect inside a custom hook.

Pure Functions â€” Like all hooks, they should be pure (no conditional hook calls)

we created a useFetch.ts file were we created the hook. 

the file explained.

Hereâ€™s a 10-line explanation of the `useFetch` custom React hook and what it means:

1. `useFetch` is a **generic React hook** for fetching data asynchronously, reusable across different components and API calls.
2. It takes two arguments: a `fetchFunction` (any async function that returns a promise) and an optional `autoFetch` flag (defaults to `true`).
3. It defines three pieces of state: `data` for storing results, `loading` to show fetch progress, and `error` to capture any failures.
4. Inside the hook, the `fetchData` function is used to call the provided `fetchFunction`, updating `loading`, `data`, and `error` accordingly.
5. The `try...catch` block ensures graceful handling of errors, converting unknown errors to a proper `Error` object.
6. A `reset` function is also included to clear `data`, `loading`, and `error`, useful for resetting state on demand.
7. The `useEffect` hook runs once when the component mounts â€” it calls `fetchData()` automatically if `autoFetch` is `true`.
8. The hook returns an object containing `data`, `loading`, `error`, a `refetch` function to manually trigger fetching, and `reset`.
9. This hook simplifies API integration by centralizing fetch logic and providing reusable loading/error state handling.
10. Example usage: `const { data, loading, error, refetch } = useFetch(() => fetchMovies({ query: 'Avengers' }))`.

Let me know if you want a version of this hook with pagination, query params, or dependency-based auto-fetching!

